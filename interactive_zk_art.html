<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive zk-SNARK Art</title>
    <!-- Include p5.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <!-- Include jsSHA library for cryptographic hashing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsSHA/2.4.2/sha256.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400&display=swap" rel="stylesheet"> <!-- Sleek font -->
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif; /* Use sleek font */
            background-color: #FAF8F5;
            overflow: hidden;
        }
        .button {
            position: absolute;
            padding: 10px 20px;
            background-color: #444;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Add shadow for depth */
        }
        .button:hover {
            background-color: #666;
        }
        .hashText {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            color: black; /* Change text color to black */
            text-align: center;
            opacity: 0.8; /* Slight transparency for a sleek look */
        }
    </style>
</head>
<body>
    <button class="button" id="proveButton" style="top: 20px; left: 20px;">Prove without Revealing</button>
    <button class="button" id="resetButton" style="top: 60px; left: 20px;">Reset</button>

    <div class="hashText" id="hashText" style="display: none;"></div>

    <script>
        let drawing = [];
        let proofFragments = [];
        let proving = false;
        let cryptographicHash = "";
        let blocks = [];

        function setup() {
            createCanvas(windowWidth, windowHeight);
            background(250, 250, 245);
            smooth(); // Enable anti-aliasing for smoother lines

            // Event listeners for buttons
            document.getElementById('proveButton').addEventListener('click', generateProof);
            document.getElementById('resetButton').addEventListener('click', resetCanvas);

            textAlign(CENTER);
            textSize(14);
            fill(50);
        }

        function draw() {
            background(250, 250, 245, 50); // Light background for smooth visuals

            if (!proving) {
                // Drawing the user's input with hot pink ink
                stroke(255, 20, 147); // Hot pink color
                strokeWeight(4); // Thicker stroke for better visibility
                noFill();
                drawCurves(drawing);
            } else {
                // Showing proof fragments (abstract proof representation)
                for (let i = 0; i < proofFragments.length; i++) {
                    fill(proofFragments[i].color);
                    ellipse(proofFragments[i].x, proofFragments[i].y, proofFragments[i].size);
                    proofFragments[i].move();
                }
            }

            // Displaying the blockchain blocks visually
            for (let i = 0; i < blocks.length; i++) {
                blocks[i].show();
            }
        }

        function mouseDragged() {
            // Store the current mouse position while dragging
            drawing.push(createVector(mouseX, mouseY));
        }

        function drawCurves(points) {
            if (points.length < 2) return;

            beginShape();
            for (let i = 0; i < points.length; i++) {
                vertex(points[i].x, points[i].y);
            }
            endShape();
        }

        function resetCanvas() {
            drawing = [];
            proofFragments = [];
            proving = false;
            cryptographicHash = "";
            blocks = [];
            document.getElementById('hashText').style.display = 'none';
            background(250, 250, 245);
        }

        function generateProof() {
            if (drawing.length === 0) {
                alert("Please draw something before generating proof.");
                return;
            }

            proving = true;
            proofFragments = [];
            cryptographicHash = "";

            // Generate a cryptographic hash of the drawing's coordinates
            let shaObj = new jsSHA("SHA-256", "TEXT");
            shaObj.update(JSON.stringify(drawing));
            cryptographicHash = shaObj.getHash("HEX");

            // Check if the hash was generated
            if (!cryptographicHash) {
                alert("Hash generation failed.");
                return;
            }

            // Create a new block in the blockchain
            let newBlock = {
                hash: cryptographicHash,
                prevHash: blocks.length > 0 ? blocks[blocks.length - 1].hash : "Genesis Block",
                x: 200 + blocks.length * 150,
                y: height / 2,
                color: color(random(100, 255), random(100, 255), random(100, 255)),
                show: function () {
                    fill(this.color);
                    rect(this.x, this.y, 120, 50);
                    fill(0);
                    text(`Hash: ${this.hash.substring(0, 8)}`, this.x + 60, this.y + 25);
                }
            };

            // Add the new block to the blocks array
            blocks.push(newBlock);

            // Check if the block was created and added
            if (blocks.length === 0 || blocks[blocks.length - 1].hash !== cryptographicHash) {
                alert("Block creation failed.");
                return;
            }

            // Generate proof fragments for visual representation
            let numFragments = 150;
            for (let i = 0; i < numFragments; i++) {
                let index = int(random(drawing.length));
                let fragment = {
                    x: drawing[index].x + random(-20, 20),
                    y: drawing[index].y + random(-20, 20),
                    size: random(10, 50),
                    color: color(random(100, 255), random(100, 255), random(100, 255), 150),
                    move: function () {
                        this.x += random(-1, 1);
                        this.y += random(-1, 1);
                    }
                };
                proofFragments.push(fragment);
            }

            // Display the hash after proof is generated
            document.getElementById('hashText').innerText = "Cryptographic Hash: " + cryptographicHash;
            document.getElementById('hashText').style.display = 'block';

            // Alert to indicate the proof is ready
            setTimeout(() => {
                alert("Your proof is ready! Hash: " + cryptographicHash);
            }, 1000);
        }
    </script>
</body>
</html>
